# Web03 - A Byte of HTTP

## 概述
我们在这节来学习一下HTTP这个和Web工程师很有缘分的协议。HTTP我想小蒲平时已经很熟悉了，但我们还是专门放一节课来强调它的重要性。这是一个既简单又复杂的协议，简单在它本身简明的设计：文本协议、无状态、规则简洁；复杂则是因为Web领域的几乎所有问题都是围绕它来实现的。这份讲义也只是点到为止，让你有所认识，更深入的领会无疑需要在实际工作中反复应用并思考得来。


## 十万个不为什么
在讲义一开始，我给出几个问题，小蒲可以用来做知识自检。思考这些问题后，再进行讲义的学习。我今后的教程也会更倾向于问答引导，而不是面面俱到的概述，这样会对你把知识吸收消化有所帮助。

+ 我们访问一个网站，比如`http://www.yahoo.com`， 会发出很多个HTTP请求，为什么？只用一个好不好？
+ 浏览器是怎么知道服务器给它的是什么文件？JS，HTML，还是CSS，或者是一段JSON，一个zip文件？
+ HTTP是`无状态`且`非双工`的，分别是什么意思？
+ 我们登录一个网站后，通常很长时间都不用再登录，这是怎么实现的？


## HTTP基础
HTTP是一个应用层协议，像大多数应用层协议一样，是建立在传输层协议TCP之上的（为什么不是UDP或其他？），我们常说它的默认端口号是80，就是说它TCP一层默认用80作为`目的`端口号。为了证明这一点，我们可以用telnet这个工具来进行实验，对HTTP有一个更基本的认识。(telnet是一个可以用来进行任何TCP链接模拟实验)

1. 打开终端，输入
    
    `telnet www.baidu.com 80`

2. 不出意外你会建立一个和百度服务器的TCP连接，由于HTTP是文本协议，所以很方便，我们可以用telnet来`手写`这个协议，继续输入

        GET / HTTP/1.1 (回车)
        Host: www.baidu.com (回车)
        (回车)

注意最后需要有一个多余回车，因为HTTP协议规定是用一个空行来分隔HTTP的Header和Body的。我们这里做了什么呢？就是请求了百度的主页`/`，
第一行由三部分组成，`GET`是谓词，我们上节简要介绍过；`/`是path，也就是主页；`HTTP/1.1`是协议版本，1.1是当下最常见的版本，最近2.0已经发布，还没有推广开，我们不展开。第二行开始就是Header部分了，这里我们只有一个Header，就是Host。

这其实就是一个极为简答的请求，百度服务器会给你response

    HTTP/1.1 200 OK
    Date: Mon, 27 Oct 2014 12:14:57 GMT
    Content-Type: text/html
    Content-Length: 14613
    Last-Modified: Wed, 03 Sep 2014 02:48:32 GMT
    Connection: Keep-Alive
    Vary: Accept-Encoding
    Set-Cookie: BAIDUID=9C2E474B996CDD54DB0B4E20A116FDD9:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com
    Set-Cookie: BAIDUPSID=9C2E474B996CDD54DB0B4E20A116FDD9; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com
    Set-Cookie: BDSVRTM=0; path=/
    P3P: CP=" OTI DSP COR IVA OUR IND COM "
    Server: BWS/1.1
    Pragma: no-cache
    Cache-control: no-cache
    BDPAGETYPE: 1
    BDQID: 0xa9969e280000247a
    BDUSERID: 0
    Accept-Ranges: bytes

    <!DOCTYPE html><!--STATUS OK-->
    <html>
    ...

响应也分三部分，第一行是状态，第二行开始是响应Header，空行之后是响应Body。从`Content-Type`头我们知道，body里是html内容（如果是浏览器就会知道要用html的方式来渲染它）；`Content-Length`指明body的大小，以byte计算; `Set-Cookie`则告诉浏览器需要把这些键值对存下来，下次访问我的时候再带给我。注意Cookie是domain相关的，同样有跨域限制，也就是说www.baidu.com只能设自己的（或者通用上级域名.baidu.com）cookie。这个机制作用很大，HTTP这个无状态协议上实现会话，跟踪用户行为（广告常用）通常要借助它来完成。其他Header各有其用，我们不展开，实践中要多总结。当然，并不是所有的Header都是协议中规范死的，你可以定义自己的Header，客户端-服务器端达成一致，协商好怎么用就行，比如这里的`BDQID`什么的，就是百度自定义的。

小蒲自己试试用telnet手写HTTP协议，加深理解~另外，还是要说Fiddler，是构造任意HTTP请求的利器~

## HTTP状态码
HTTP的状态码有很多，常见的其实只有几种。

+ 2XX：正常。刚才我们已经见到了200，这表示请求成功。
+ 3XX：重定向。最常见的是301和302，301表示“永久性”重定向，302表示“临时”重定向。浏览器对它们俩的行为是一样的，都是取出响应头中的`Location`，把当前页面转向这个地址。那301和302区别在什么地方呢？主要在语义上的差别，比如搜索引擎（爬虫）对它们的理解是不一样的，比如A网页301到了B网页，那么按照约定搜索引擎会将A的权重导给B，而如果是302，则不会。
+ 4XX：浏览器端错误。一般指参数没传对、没有权限等等。401是未授权(按约定浏览器会触发一个输入用户名密码的提示框)，403是禁止访问，404是找不到。
+ 5XX：服务器端错误。

## 重要的HTTP头
大部分的Web功能都是通过HTTP头来协商实现的(比如协商压缩编码、会话、下载时断点续传、简单缓存等等)。我们在telnet一节已经介绍了几个重要的HTTP头，这里再介绍一些常见Header（注意区分Request头和Response头，有的Header在两种头中都有定义）：

#### Request头
+ Accept-Encoding：表示可以接受哪些编码的响应，就是浏览器告诉服务器，`我`只能看懂这些编码，比如gzip，不要用超出我理解范围的编码。
+ Connection：是否要持久链接，HTTP1.1是默认开启持久连接的，关闭它需要这个头设为close
+ Cookie：浏览器会根据之前讲的cookie机制，自动带上这个域的cookie
+ Referer：先前网页的地址（就是从哪发出这个请求）
+ User-Agent：浏览器标识符

#### Response头
+ Content-Encoding：上面telnet一节介绍过了
+ Location：30X时的重定向目标

还有很多有用的值得关注的头，这里不一一列举，相信在工作中你会逐渐熟悉。

## Web框架中的HTTP
你可能会有疑问，我平时写web服务，MVC什么的，很少直接接触到HTTP一层，这是怎么回事？这就是Web框架的价值所在，它们把常见的场景封装了起来，处理HTTP头，填充状态码这些事情都在背后贴心地帮你做了，大多数场景你都不需要去干预这个过程。但是你自己要清楚背后发生了什么，惟其如此，才能有深入的理解。

具体到我们上次介绍的webpy，它的关于HTTP的封装主要在[webapi.py](../../vendor/webpy/web/webapi.py)这个文件里。不要求你现在读懂，隔一段时间浏览一遍，把能看懂的部分记下来，对照学习。

## 拓展阅读

+ 《HTTP权威指南》，在第一讲的工具链接里可以找到，不要求现在全部读完，希望能够仔细阅读它的`前言`和`目录`，我不是在搞笑，是想让你了解它的每一章在聊什么问题。这本书覆盖面非常广，读他的方式就是一点一点蚕食，前三章建议现在就可以通读不存在问题。之后的章节基本上各自在讨论特定的问题，需要在实践中有目的的阅读，这也是为什么我让你仔细阅读他的前言和目录的原因——当你在实践中要解决某个问题是，记得回来读相关的部分。当你对这本书的大部分内容都有了一定程度的了解，可以说你已经是一个相当不错的Web工程师了~

## Homework
1. 回答讲义前面的几个问题
2. 上一节的补充作业里有一个是用Fiddler构造请求在Blog里发一个贴，今天的是用前面介绍的telnet构造请求发一个贴:D
3. 关于本次的主题（讲义内外都可以），提出几个问题 （这个提问题的环节我以后会一直保留~）

练习的时候有任何问题要来问哦，不要不好意思~ mua~

