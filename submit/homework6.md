1. 进程与线程。
    * 一个程序至少有一个进程，每个进程有独立的运行环境，包括内存、寄存器、环境变量等。复杂的程序可以有多个进程，每个进程独立地执行，不会对其它进程产生干扰。如果进程间需要通信，可以通过以下方式进行：
        + 管道和命名管道：管道即一个进程的输出是另一个进程的输入，可用于有亲缘关系的进程间的通信。其原理是父进程创建管道，然后fork出子进程，父子进程分别关闭读写端中的一个，就能通过对管道进行读写而实现通信了。命名管道原理类似，即不同进程指向同一块内存进行读写，从而实现通信。
        + 信号：进程间通过发送信号通信，信号是软件层次上对中断的的一种模拟。进程A发送信号给进程B，系统调用进入kernel态，由kernel处理当前可传送的信号，并调用信号的处理函数（有默认动作，部分信号也可注册处理函数）会用户态执行，执行完成后执行特殊信号返回kernel态，由kernel再切换回进程A中断处继续执行。（如果进程B处于未执行状态，则信号先由kernel保存；若有设置信号阻塞，则取消阻塞后才会发送）
        + 消息队列：消息队列是在内存中维护的一个链表。有写权限的进程按照一定规则想队列中添加消息，有读权限的进程则可以从队列中读取消息。
        + 共享内存：多个进程可访问同一块内存，因此可以看到彼此的数据。但需要同步机制（锁、信号量等）。
        + 套接口：一般用于不同机器进程间的通信。
    * 线程是CPU调度和分派的最小单元，一个进程至少包含一个线程，每个线程有自己独立的线程ID、栈、寄存器和条件变量，其他资源则与进程中的其它线程共享，因此会有同步问题。

2. 多线程应用场景：
    * 程序中涉及IO异步操作：IO处理速度相比CPU要慢很多，因此如果程序中有很多读写、socket等IO操作时，如果使用单线程，CPU在IO操作时处于空闲状态，一方面浪费CPU资源，一方面程序处于假死状态，用户体验差。如我们上节课涉及到的web server，有频繁的socket操作，如果使用多线程，就可以在IO操作时利用空闲的CPU处理请求具体内容。
    * 程序中并发任务较多：程序中有较多相对独立的并发任务，一方面任务间没有强耦合，一方面不能等一个执行完再执行另一个，比如主任务和监控任务要同时执行。
    * 大任务分解：如果涉及大量数据操作和计算，虽然也可以单线程实现，但对于多核处理器可以分解成多线程处理，充分利用硬件资源。

3. 由于线程间共享内存等资源，如果不同线程要访问相同的数据，就需要进行同步。同步主要有以下几种方式：
    * 锁：加锁的区域同时只能有一个线程可访问，其它线程必须等到当前有锁的线程将锁释放后才能访问该区域（有机会获得该区域的锁）。锁可以通过critical section和mutex等方式实现。
    * 信号量：信号量是个非负整数，当线程访问有信号量机制的区域时，信号量减1；离开该区域时，信号量加1；当信号量为0时，线程不被允许进入该区域，直到信号量又变为正。锁即是信号量最大值设为1的特殊情况。锁和信号量用于同时最多只能有1（或N）个线程访问某代码段时。
    * 条件变量：等待某一条件的发送。当条件不成立的时候，线程阻塞自己；条件成立后，线程继续执行，并在执行完成后唤醒等待同一条件的其他线程。条件变量必须与锁一起使用。

4. 看了老师年轻时候写的文章，逼格太高，我这种思想比较朴素的理解起来比较困难，尤其是数学属于考完试就还给老师的。。。主要有以下几个问题：
    * 为什么hb（happens-before）的不是tb（time-before）的？反过来比较好理解。
    * 讲到JMM的时候有个例子：
    初始条件：x = y = 0

        Thread 1:
        a = x;  //A
        b = a | 1;  //B
        y = b;  //C

        Thread 2:
        c = y;  //D
        x = c;  //E

    为什么可以出现a=b=c=1这种情况呢？因为感觉a是不可能等于1的啊（线程不会重复运行）。
    * 在讨论synchronized关键字时，如果在类内部声明一个lock，并对该lock加锁，这时候会禁止了“客户代码加锁”的行为，这是为什么？
